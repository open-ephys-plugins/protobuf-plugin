// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aibsmw_messages.proto

#ifndef PROTOBUF_aibsmw_5fmessages_2eproto__INCLUDED
#define PROTOBUF_aibsmw_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_aibsmw_5fmessages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsmessage_headerImpl();
void InitDefaultsmessage_header();
void InitDefaultsgeneric_heartbeatImpl();
void InitDefaultsgeneric_heartbeat();
void InitDefaultsremote_device_heartbeatImpl();
void InitDefaultsremote_device_heartbeat();
void InitDefaultsrequest_remote_devicesImpl();
void InitDefaultsrequest_remote_devices();
void InitDefaultsrouter_aliveImpl();
void InitDefaultsrouter_alive();
void InitDefaultsremote_devices_listImpl();
void InitDefaultsremote_devices_list();
void InitDefaultsremote_service_requestImpl();
void InitDefaultsremote_service_request();
void InitDefaultsremote_service_replyImpl();
void InitDefaultsremote_service_reply();
void InitDefaultssystem_notificationImpl();
void InitDefaultssystem_notification();
void InitDefaultspython_infoImpl();
void InitDefaultspython_info();
void InitDefaultshost_infoImpl();
void InitDefaultshost_info();
void InitDefaultsplatform_infoImpl();
void InitDefaultsplatform_info();
void InitDefaultsregister_for_messageImpl();
void InitDefaultsregister_for_message();
void InitDefaultsderegister_for_messageImpl();
void InitDefaultsderegister_for_message();
inline void InitDefaults() {
  InitDefaultsmessage_header();
  InitDefaultsgeneric_heartbeat();
  InitDefaultsremote_device_heartbeat();
  InitDefaultsrequest_remote_devices();
  InitDefaultsrouter_alive();
  InitDefaultsremote_devices_list();
  InitDefaultsremote_service_request();
  InitDefaultsremote_service_reply();
  InitDefaultssystem_notification();
  InitDefaultspython_info();
  InitDefaultshost_info();
  InitDefaultsplatform_info();
  InitDefaultsregister_for_message();
  InitDefaultsderegister_for_message();
}
}  // namespace protobuf_aibsmw_5fmessages_2eproto
class deregister_for_message;
class deregister_for_messageDefaultTypeInternal;
extern deregister_for_messageDefaultTypeInternal _deregister_for_message_default_instance_;
class generic_heartbeat;
class generic_heartbeatDefaultTypeInternal;
extern generic_heartbeatDefaultTypeInternal _generic_heartbeat_default_instance_;
class host_info;
class host_infoDefaultTypeInternal;
extern host_infoDefaultTypeInternal _host_info_default_instance_;
class message_header;
class message_headerDefaultTypeInternal;
extern message_headerDefaultTypeInternal _message_header_default_instance_;
class platform_info;
class platform_infoDefaultTypeInternal;
extern platform_infoDefaultTypeInternal _platform_info_default_instance_;
class python_info;
class python_infoDefaultTypeInternal;
extern python_infoDefaultTypeInternal _python_info_default_instance_;
class register_for_message;
class register_for_messageDefaultTypeInternal;
extern register_for_messageDefaultTypeInternal _register_for_message_default_instance_;
class remote_device_heartbeat;
class remote_device_heartbeatDefaultTypeInternal;
extern remote_device_heartbeatDefaultTypeInternal _remote_device_heartbeat_default_instance_;
class remote_devices_list;
class remote_devices_listDefaultTypeInternal;
extern remote_devices_listDefaultTypeInternal _remote_devices_list_default_instance_;
class remote_service_reply;
class remote_service_replyDefaultTypeInternal;
extern remote_service_replyDefaultTypeInternal _remote_service_reply_default_instance_;
class remote_service_request;
class remote_service_requestDefaultTypeInternal;
extern remote_service_requestDefaultTypeInternal _remote_service_request_default_instance_;
class request_remote_devices;
class request_remote_devicesDefaultTypeInternal;
extern request_remote_devicesDefaultTypeInternal _request_remote_devices_default_instance_;
class router_alive;
class router_aliveDefaultTypeInternal;
extern router_aliveDefaultTypeInternal _router_alive_default_instance_;
class system_notification;
class system_notificationDefaultTypeInternal;
extern system_notificationDefaultTypeInternal _system_notification_default_instance_;

enum remote_service_request_COMMAND_TYPES {
  remote_service_request_COMMAND_TYPES_CMD_RUN = 0,
  remote_service_request_COMMAND_TYPES_CMD_SET = 1,
  remote_service_request_COMMAND_TYPES_CMD_GET = 2,
  remote_service_request_COMMAND_TYPES_CMD_CALLABLE = 3,
  remote_service_request_COMMAND_TYPES_CMD_PLATFORM_INFO = 4
};
bool remote_service_request_COMMAND_TYPES_IsValid(int value);
const remote_service_request_COMMAND_TYPES remote_service_request_COMMAND_TYPES_COMMAND_TYPES_MIN = remote_service_request_COMMAND_TYPES_CMD_RUN;
const remote_service_request_COMMAND_TYPES remote_service_request_COMMAND_TYPES_COMMAND_TYPES_MAX = remote_service_request_COMMAND_TYPES_CMD_PLATFORM_INFO;
const int remote_service_request_COMMAND_TYPES_COMMAND_TYPES_ARRAYSIZE = remote_service_request_COMMAND_TYPES_COMMAND_TYPES_MAX + 1;

const ::google::protobuf::EnumDescriptor* remote_service_request_COMMAND_TYPES_descriptor();
inline const ::std::string& remote_service_request_COMMAND_TYPES_Name(remote_service_request_COMMAND_TYPES value) {
  return ::google::protobuf::internal::NameOfEnum(
    remote_service_request_COMMAND_TYPES_descriptor(), value);
}
inline bool remote_service_request_COMMAND_TYPES_Parse(
    const ::std::string& name, remote_service_request_COMMAND_TYPES* value) {
  return ::google::protobuf::internal::ParseNamedEnum<remote_service_request_COMMAND_TYPES>(
    remote_service_request_COMMAND_TYPES_descriptor(), name, value);
}
enum remote_service_reply_CALL_RESULT_TYPES {
  remote_service_reply_CALL_RESULT_TYPES_RESULT_FAILED = 0,
  remote_service_reply_CALL_RESULT_TYPES_RESULT_PROCESSED = 1
};
bool remote_service_reply_CALL_RESULT_TYPES_IsValid(int value);
const remote_service_reply_CALL_RESULT_TYPES remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_MIN = remote_service_reply_CALL_RESULT_TYPES_RESULT_FAILED;
const remote_service_reply_CALL_RESULT_TYPES remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_MAX = remote_service_reply_CALL_RESULT_TYPES_RESULT_PROCESSED;
const int remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_ARRAYSIZE = remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_MAX + 1;

const ::google::protobuf::EnumDescriptor* remote_service_reply_CALL_RESULT_TYPES_descriptor();
inline const ::std::string& remote_service_reply_CALL_RESULT_TYPES_Name(remote_service_reply_CALL_RESULT_TYPES value) {
  return ::google::protobuf::internal::NameOfEnum(
    remote_service_reply_CALL_RESULT_TYPES_descriptor(), value);
}
inline bool remote_service_reply_CALL_RESULT_TYPES_Parse(
    const ::std::string& name, remote_service_reply_CALL_RESULT_TYPES* value) {
  return ::google::protobuf::internal::ParseNamedEnum<remote_service_reply_CALL_RESULT_TYPES>(
    remote_service_reply_CALL_RESULT_TYPES_descriptor(), name, value);
}
enum system_notification_status_type {
  system_notification_status_type_ERROR = 1,
  system_notification_status_type_UPDATE = 2
};
bool system_notification_status_type_IsValid(int value);
const system_notification_status_type system_notification_status_type_status_type_MIN = system_notification_status_type_ERROR;
const system_notification_status_type system_notification_status_type_status_type_MAX = system_notification_status_type_UPDATE;
const int system_notification_status_type_status_type_ARRAYSIZE = system_notification_status_type_status_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* system_notification_status_type_descriptor();
inline const ::std::string& system_notification_status_type_Name(system_notification_status_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    system_notification_status_type_descriptor(), value);
}
inline bool system_notification_status_type_Parse(
    const ::std::string& name, system_notification_status_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<system_notification_status_type>(
    system_notification_status_type_descriptor(), name, value);
}
// ===================================================================

class message_header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_header) */ {
 public:
  message_header();
  virtual ~message_header();

  message_header(const message_header& from);

  inline message_header& operator=(const message_header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  message_header(message_header&& from) noexcept
    : message_header() {
    *this = ::std::move(from);
  }

  inline message_header& operator=(message_header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_header* internal_default_instance() {
    return reinterpret_cast<const message_header*>(
               &_message_header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(message_header* other);
  friend void swap(message_header& a, message_header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline message_header* New() const PROTOBUF_FINAL { return New(NULL); }

  message_header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_header& from);
  void MergeFrom(const message_header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string process = 1;
  bool has_process() const;
  void clear_process();
  static const int kProcessFieldNumber = 1;
  const ::std::string& process() const;
  void set_process(const ::std::string& value);
  #if LANG_CXX11
  void set_process(::std::string&& value);
  #endif
  void set_process(const char* value);
  void set_process(const char* value, size_t size);
  ::std::string* mutable_process();
  ::std::string* release_process();
  void set_allocated_process(::std::string* process);

  // required string host = 2;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 2;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // required string message_id = 4;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 4;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // required float timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  float timestamp() const;
  void set_timestamp(float value);

  // @@protoc_insertion_point(class_scope:message_header)
 private:
  void set_has_process();
  void clear_has_process();
  void set_has_host();
  void clear_has_host();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_message_id();
  void clear_has_message_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr process_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  float timestamp_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsmessage_headerImpl();
};
// -------------------------------------------------------------------

class generic_heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:generic_heartbeat) */ {
 public:
  generic_heartbeat();
  virtual ~generic_heartbeat();

  generic_heartbeat(const generic_heartbeat& from);

  inline generic_heartbeat& operator=(const generic_heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  generic_heartbeat(generic_heartbeat&& from) noexcept
    : generic_heartbeat() {
    *this = ::std::move(from);
  }

  inline generic_heartbeat& operator=(generic_heartbeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const generic_heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const generic_heartbeat* internal_default_instance() {
    return reinterpret_cast<const generic_heartbeat*>(
               &_generic_heartbeat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(generic_heartbeat* other);
  friend void swap(generic_heartbeat& a, generic_heartbeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline generic_heartbeat* New() const PROTOBUF_FINAL { return New(NULL); }

  generic_heartbeat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const generic_heartbeat& from);
  void MergeFrom(const generic_heartbeat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(generic_heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // required float start_time = 2;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  float start_time() const;
  void set_start_time(float value);

  // @@protoc_insertion_point(class_scope:generic_heartbeat)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_start_time();
  void clear_has_start_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::message_header* header_;
  float start_time_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsgeneric_heartbeatImpl();
};
// -------------------------------------------------------------------

class remote_device_heartbeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:remote_device_heartbeat) */ {
 public:
  remote_device_heartbeat();
  virtual ~remote_device_heartbeat();

  remote_device_heartbeat(const remote_device_heartbeat& from);

  inline remote_device_heartbeat& operator=(const remote_device_heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  remote_device_heartbeat(remote_device_heartbeat&& from) noexcept
    : remote_device_heartbeat() {
    *this = ::std::move(from);
  }

  inline remote_device_heartbeat& operator=(remote_device_heartbeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const remote_device_heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const remote_device_heartbeat* internal_default_instance() {
    return reinterpret_cast<const remote_device_heartbeat*>(
               &_remote_device_heartbeat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(remote_device_heartbeat* other);
  friend void swap(remote_device_heartbeat& a, remote_device_heartbeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline remote_device_heartbeat* New() const PROTOBUF_FINAL { return New(NULL); }

  remote_device_heartbeat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const remote_device_heartbeat& from);
  void MergeFrom(const remote_device_heartbeat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(remote_device_heartbeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string device_name = 2;
  bool has_device_name() const;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 2;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // required string ip_address = 4;
  bool has_ip_address() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 4;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // required int32 port = 5;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 5;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // required float start_time = 6;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 6;
  float start_time() const;
  void set_start_time(float value);

  // @@protoc_insertion_point(class_scope:remote_device_heartbeat)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_device_name();
  void clear_has_device_name();
  void set_has_ip_address();
  void clear_has_ip_address();
  void set_has_port();
  void clear_has_port();
  void set_has_start_time();
  void clear_has_start_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::message_header* header_;
  ::google::protobuf::int32 port_;
  float start_time_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsremote_device_heartbeatImpl();
};
// -------------------------------------------------------------------

class request_remote_devices : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:request_remote_devices) */ {
 public:
  request_remote_devices();
  virtual ~request_remote_devices();

  request_remote_devices(const request_remote_devices& from);

  inline request_remote_devices& operator=(const request_remote_devices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  request_remote_devices(request_remote_devices&& from) noexcept
    : request_remote_devices() {
    *this = ::std::move(from);
  }

  inline request_remote_devices& operator=(request_remote_devices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const request_remote_devices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const request_remote_devices* internal_default_instance() {
    return reinterpret_cast<const request_remote_devices*>(
               &_request_remote_devices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(request_remote_devices* other);
  friend void swap(request_remote_devices& a, request_remote_devices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline request_remote_devices* New() const PROTOBUF_FINAL { return New(NULL); }

  request_remote_devices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const request_remote_devices& from);
  void MergeFrom(const request_remote_devices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(request_remote_devices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // @@protoc_insertion_point(class_scope:request_remote_devices)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::message_header* header_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsrequest_remote_devicesImpl();
};
// -------------------------------------------------------------------

class router_alive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:router_alive) */ {
 public:
  router_alive();
  virtual ~router_alive();

  router_alive(const router_alive& from);

  inline router_alive& operator=(const router_alive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  router_alive(router_alive&& from) noexcept
    : router_alive() {
    *this = ::std::move(from);
  }

  inline router_alive& operator=(router_alive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const router_alive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const router_alive* internal_default_instance() {
    return reinterpret_cast<const router_alive*>(
               &_router_alive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(router_alive* other);
  friend void swap(router_alive& a, router_alive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline router_alive* New() const PROTOBUF_FINAL { return New(NULL); }

  router_alive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const router_alive& from);
  void MergeFrom(const router_alive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(router_alive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string registered_messages = 2;
  int registered_messages_size() const;
  void clear_registered_messages();
  static const int kRegisteredMessagesFieldNumber = 2;
  const ::std::string& registered_messages(int index) const;
  ::std::string* mutable_registered_messages(int index);
  void set_registered_messages(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_registered_messages(int index, ::std::string&& value);
  #endif
  void set_registered_messages(int index, const char* value);
  void set_registered_messages(int index, const char* value, size_t size);
  ::std::string* add_registered_messages();
  void add_registered_messages(const ::std::string& value);
  #if LANG_CXX11
  void add_registered_messages(::std::string&& value);
  #endif
  void add_registered_messages(const char* value);
  void add_registered_messages(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& registered_messages() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_registered_messages();

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // @@protoc_insertion_point(class_scope:router_alive)
 private:
  void set_has_header();
  void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> registered_messages_;
  ::message_header* header_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsrouter_aliveImpl();
};
// -------------------------------------------------------------------

class remote_devices_list : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:remote_devices_list) */ {
 public:
  remote_devices_list();
  virtual ~remote_devices_list();

  remote_devices_list(const remote_devices_list& from);

  inline remote_devices_list& operator=(const remote_devices_list& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  remote_devices_list(remote_devices_list&& from) noexcept
    : remote_devices_list() {
    *this = ::std::move(from);
  }

  inline remote_devices_list& operator=(remote_devices_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const remote_devices_list& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const remote_devices_list* internal_default_instance() {
    return reinterpret_cast<const remote_devices_list*>(
               &_remote_devices_list_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(remote_devices_list* other);
  friend void swap(remote_devices_list& a, remote_devices_list& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline remote_devices_list* New() const PROTOBUF_FINAL { return New(NULL); }

  remote_devices_list* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const remote_devices_list& from);
  void MergeFrom(const remote_devices_list& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(remote_devices_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string devices = 2;
  bool has_devices() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 2;
  const ::std::string& devices() const;
  void set_devices(const ::std::string& value);
  #if LANG_CXX11
  void set_devices(::std::string&& value);
  #endif
  void set_devices(const char* value);
  void set_devices(const char* value, size_t size);
  ::std::string* mutable_devices();
  ::std::string* release_devices();
  void set_allocated_devices(::std::string* devices);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // @@protoc_insertion_point(class_scope:remote_devices_list)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_devices();
  void clear_has_devices();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr devices_;
  ::message_header* header_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsremote_devices_listImpl();
};
// -------------------------------------------------------------------

class remote_service_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:remote_service_request) */ {
 public:
  remote_service_request();
  virtual ~remote_service_request();

  remote_service_request(const remote_service_request& from);

  inline remote_service_request& operator=(const remote_service_request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  remote_service_request(remote_service_request&& from) noexcept
    : remote_service_request() {
    *this = ::std::move(from);
  }

  inline remote_service_request& operator=(remote_service_request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const remote_service_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const remote_service_request* internal_default_instance() {
    return reinterpret_cast<const remote_service_request*>(
               &_remote_service_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(remote_service_request* other);
  friend void swap(remote_service_request& a, remote_service_request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline remote_service_request* New() const PROTOBUF_FINAL { return New(NULL); }

  remote_service_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const remote_service_request& from);
  void MergeFrom(const remote_service_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(remote_service_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef remote_service_request_COMMAND_TYPES COMMAND_TYPES;
  static const COMMAND_TYPES CMD_RUN =
    remote_service_request_COMMAND_TYPES_CMD_RUN;
  static const COMMAND_TYPES CMD_SET =
    remote_service_request_COMMAND_TYPES_CMD_SET;
  static const COMMAND_TYPES CMD_GET =
    remote_service_request_COMMAND_TYPES_CMD_GET;
  static const COMMAND_TYPES CMD_CALLABLE =
    remote_service_request_COMMAND_TYPES_CMD_CALLABLE;
  static const COMMAND_TYPES CMD_PLATFORM_INFO =
    remote_service_request_COMMAND_TYPES_CMD_PLATFORM_INFO;
  static inline bool COMMAND_TYPES_IsValid(int value) {
    return remote_service_request_COMMAND_TYPES_IsValid(value);
  }
  static const COMMAND_TYPES COMMAND_TYPES_MIN =
    remote_service_request_COMMAND_TYPES_COMMAND_TYPES_MIN;
  static const COMMAND_TYPES COMMAND_TYPES_MAX =
    remote_service_request_COMMAND_TYPES_COMMAND_TYPES_MAX;
  static const int COMMAND_TYPES_ARRAYSIZE =
    remote_service_request_COMMAND_TYPES_COMMAND_TYPES_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COMMAND_TYPES_descriptor() {
    return remote_service_request_COMMAND_TYPES_descriptor();
  }
  static inline const ::std::string& COMMAND_TYPES_Name(COMMAND_TYPES value) {
    return remote_service_request_COMMAND_TYPES_Name(value);
  }
  static inline bool COMMAND_TYPES_Parse(const ::std::string& name,
      COMMAND_TYPES* value) {
    return remote_service_request_COMMAND_TYPES_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string target = 3;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 3;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);

  // optional string args = 4;
  bool has_args() const;
  void clear_args();
  static const int kArgsFieldNumber = 4;
  const ::std::string& args() const;
  void set_args(const ::std::string& value);
  #if LANG_CXX11
  void set_args(::std::string&& value);
  #endif
  void set_args(const char* value);
  void set_args(const char* value, size_t size);
  ::std::string* mutable_args();
  ::std::string* release_args();
  void set_allocated_args(::std::string* args);

  // optional string kwargs = 5;
  bool has_kwargs() const;
  void clear_kwargs();
  static const int kKwargsFieldNumber = 5;
  const ::std::string& kwargs() const;
  void set_kwargs(const ::std::string& value);
  #if LANG_CXX11
  void set_kwargs(::std::string&& value);
  #endif
  void set_kwargs(const char* value);
  void set_kwargs(const char* value, size_t size);
  ::std::string* mutable_kwargs();
  ::std::string* release_kwargs();
  void set_allocated_kwargs(::std::string* kwargs);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // required .remote_service_request.COMMAND_TYPES command_type = 2;
  bool has_command_type() const;
  void clear_command_type();
  static const int kCommandTypeFieldNumber = 2;
  ::remote_service_request_COMMAND_TYPES command_type() const;
  void set_command_type(::remote_service_request_COMMAND_TYPES value);

  // @@protoc_insertion_point(class_scope:remote_service_request)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_command_type();
  void clear_has_command_type();
  void set_has_target();
  void clear_has_target();
  void set_has_args();
  void clear_has_args();
  void set_has_kwargs();
  void clear_has_kwargs();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::google::protobuf::internal::ArenaStringPtr args_;
  ::google::protobuf::internal::ArenaStringPtr kwargs_;
  ::message_header* header_;
  int command_type_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsremote_service_requestImpl();
};
// -------------------------------------------------------------------

class remote_service_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:remote_service_reply) */ {
 public:
  remote_service_reply();
  virtual ~remote_service_reply();

  remote_service_reply(const remote_service_reply& from);

  inline remote_service_reply& operator=(const remote_service_reply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  remote_service_reply(remote_service_reply&& from) noexcept
    : remote_service_reply() {
    *this = ::std::move(from);
  }

  inline remote_service_reply& operator=(remote_service_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const remote_service_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const remote_service_reply* internal_default_instance() {
    return reinterpret_cast<const remote_service_reply*>(
               &_remote_service_reply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(remote_service_reply* other);
  friend void swap(remote_service_reply& a, remote_service_reply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline remote_service_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  remote_service_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const remote_service_reply& from);
  void MergeFrom(const remote_service_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(remote_service_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef remote_service_reply_CALL_RESULT_TYPES CALL_RESULT_TYPES;
  static const CALL_RESULT_TYPES RESULT_FAILED =
    remote_service_reply_CALL_RESULT_TYPES_RESULT_FAILED;
  static const CALL_RESULT_TYPES RESULT_PROCESSED =
    remote_service_reply_CALL_RESULT_TYPES_RESULT_PROCESSED;
  static inline bool CALL_RESULT_TYPES_IsValid(int value) {
    return remote_service_reply_CALL_RESULT_TYPES_IsValid(value);
  }
  static const CALL_RESULT_TYPES CALL_RESULT_TYPES_MIN =
    remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_MIN;
  static const CALL_RESULT_TYPES CALL_RESULT_TYPES_MAX =
    remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_MAX;
  static const int CALL_RESULT_TYPES_ARRAYSIZE =
    remote_service_reply_CALL_RESULT_TYPES_CALL_RESULT_TYPES_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CALL_RESULT_TYPES_descriptor() {
    return remote_service_reply_CALL_RESULT_TYPES_descriptor();
  }
  static inline const ::std::string& CALL_RESULT_TYPES_Name(CALL_RESULT_TYPES value) {
    return remote_service_reply_CALL_RESULT_TYPES_Name(value);
  }
  static inline bool CALL_RESULT_TYPES_Parse(const ::std::string& name,
      CALL_RESULT_TYPES* value) {
    return remote_service_reply_CALL_RESULT_TYPES_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string reply = 3;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 3;
  const ::std::string& reply() const;
  void set_reply(const ::std::string& value);
  #if LANG_CXX11
  void set_reply(::std::string&& value);
  #endif
  void set_reply(const char* value);
  void set_reply(const char* value, size_t size);
  ::std::string* mutable_reply();
  ::std::string* release_reply();
  void set_allocated_reply(::std::string* reply);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // required .remote_service_reply.CALL_RESULT_TYPES call_result = 2;
  bool has_call_result() const;
  void clear_call_result();
  static const int kCallResultFieldNumber = 2;
  ::remote_service_reply_CALL_RESULT_TYPES call_result() const;
  void set_call_result(::remote_service_reply_CALL_RESULT_TYPES value);

  // @@protoc_insertion_point(class_scope:remote_service_reply)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_call_result();
  void clear_has_call_result();
  void set_has_reply();
  void clear_has_reply();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reply_;
  ::message_header* header_;
  int call_result_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsremote_service_replyImpl();
};
// -------------------------------------------------------------------

class system_notification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:system_notification) */ {
 public:
  system_notification();
  virtual ~system_notification();

  system_notification(const system_notification& from);

  inline system_notification& operator=(const system_notification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  system_notification(system_notification&& from) noexcept
    : system_notification() {
    *this = ::std::move(from);
  }

  inline system_notification& operator=(system_notification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const system_notification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const system_notification* internal_default_instance() {
    return reinterpret_cast<const system_notification*>(
               &_system_notification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(system_notification* other);
  friend void swap(system_notification& a, system_notification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline system_notification* New() const PROTOBUF_FINAL { return New(NULL); }

  system_notification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const system_notification& from);
  void MergeFrom(const system_notification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(system_notification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef system_notification_status_type status_type;
  static const status_type ERROR2 =
    system_notification_status_type_ERROR;
  static const status_type UPDATE =
    system_notification_status_type_UPDATE;
  static inline bool status_type_IsValid(int value) {
    return system_notification_status_type_IsValid(value);
  }
  static const status_type status_type_MIN =
    system_notification_status_type_status_type_MIN;
  static const status_type status_type_MAX =
    system_notification_status_type_status_type_MAX;
  static const int status_type_ARRAYSIZE =
    system_notification_status_type_status_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  status_type_descriptor() {
    return system_notification_status_type_descriptor();
  }
  static inline const ::std::string& status_type_Name(status_type value) {
    return system_notification_status_type_Name(value);
  }
  static inline bool status_type_Parse(const ::std::string& name,
      status_type* value) {
    return system_notification_status_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // required .system_notification.status_type status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::system_notification_status_type status() const;
  void set_status(::system_notification_status_type value);

  // @@protoc_insertion_point(class_scope:system_notification)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_status();
  void clear_has_status();
  void set_has_message();
  void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::message_header* header_;
  int status_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultssystem_notificationImpl();
};
// -------------------------------------------------------------------

class python_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:python_info) */ {
 public:
  python_info();
  virtual ~python_info();

  python_info(const python_info& from);

  inline python_info& operator=(const python_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  python_info(python_info&& from) noexcept
    : python_info() {
    *this = ::std::move(from);
  }

  inline python_info& operator=(python_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const python_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const python_info* internal_default_instance() {
    return reinterpret_cast<const python_info*>(
               &_python_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(python_info* other);
  friend void swap(python_info& a, python_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline python_info* New() const PROTOBUF_FINAL { return New(NULL); }

  python_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const python_info& from);
  void MergeFrom(const python_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(python_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string build_number = 1;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 1;
  const ::std::string& build_number() const;
  void set_build_number(const ::std::string& value);
  #if LANG_CXX11
  void set_build_number(::std::string&& value);
  #endif
  void set_build_number(const char* value);
  void set_build_number(const char* value, size_t size);
  ::std::string* mutable_build_number();
  ::std::string* release_build_number();
  void set_allocated_build_number(::std::string* build_number);

  // required string build_date = 2;
  bool has_build_date() const;
  void clear_build_date();
  static const int kBuildDateFieldNumber = 2;
  const ::std::string& build_date() const;
  void set_build_date(const ::std::string& value);
  #if LANG_CXX11
  void set_build_date(::std::string&& value);
  #endif
  void set_build_date(const char* value);
  void set_build_date(const char* value, size_t size);
  ::std::string* mutable_build_date();
  ::std::string* release_build_date();
  void set_allocated_build_date(::std::string* build_date);

  // required string compiler = 3;
  bool has_compiler() const;
  void clear_compiler();
  static const int kCompilerFieldNumber = 3;
  const ::std::string& compiler() const;
  void set_compiler(const ::std::string& value);
  #if LANG_CXX11
  void set_compiler(::std::string&& value);
  #endif
  void set_compiler(const char* value);
  void set_compiler(const char* value, size_t size);
  ::std::string* mutable_compiler();
  ::std::string* release_compiler();
  void set_allocated_compiler(::std::string* compiler);

  // required string branch = 4;
  bool has_branch() const;
  void clear_branch();
  static const int kBranchFieldNumber = 4;
  const ::std::string& branch() const;
  void set_branch(const ::std::string& value);
  #if LANG_CXX11
  void set_branch(::std::string&& value);
  #endif
  void set_branch(const char* value);
  void set_branch(const char* value, size_t size);
  ::std::string* mutable_branch();
  ::std::string* release_branch();
  void set_allocated_branch(::std::string* branch);

  // required string implementation = 5;
  bool has_implementation() const;
  void clear_implementation();
  static const int kImplementationFieldNumber = 5;
  const ::std::string& implementation() const;
  void set_implementation(const ::std::string& value);
  #if LANG_CXX11
  void set_implementation(::std::string&& value);
  #endif
  void set_implementation(const char* value);
  void set_implementation(const char* value, size_t size);
  ::std::string* mutable_implementation();
  ::std::string* release_implementation();
  void set_allocated_implementation(::std::string* implementation);

  // required string revision = 6;
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 6;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // required string version = 7;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required string exec_prefix = 8;
  bool has_exec_prefix() const;
  void clear_exec_prefix();
  static const int kExecPrefixFieldNumber = 8;
  const ::std::string& exec_prefix() const;
  void set_exec_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_exec_prefix(::std::string&& value);
  #endif
  void set_exec_prefix(const char* value);
  void set_exec_prefix(const char* value, size_t size);
  ::std::string* mutable_exec_prefix();
  ::std::string* release_exec_prefix();
  void set_allocated_exec_prefix(::std::string* exec_prefix);

  // required bool is_conda = 10;
  bool has_is_conda() const;
  void clear_is_conda();
  static const int kIsCondaFieldNumber = 10;
  bool is_conda() const;
  void set_is_conda(bool value);

  // @@protoc_insertion_point(class_scope:python_info)
 private:
  void set_has_build_number();
  void clear_has_build_number();
  void set_has_build_date();
  void clear_has_build_date();
  void set_has_compiler();
  void clear_has_compiler();
  void set_has_branch();
  void clear_has_branch();
  void set_has_implementation();
  void clear_has_implementation();
  void set_has_revision();
  void clear_has_revision();
  void set_has_version();
  void clear_has_version();
  void set_has_exec_prefix();
  void clear_has_exec_prefix();
  void set_has_is_conda();
  void clear_has_is_conda();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr build_number_;
  ::google::protobuf::internal::ArenaStringPtr build_date_;
  ::google::protobuf::internal::ArenaStringPtr compiler_;
  ::google::protobuf::internal::ArenaStringPtr branch_;
  ::google::protobuf::internal::ArenaStringPtr implementation_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr exec_prefix_;
  bool is_conda_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultspython_infoImpl();
};
// -------------------------------------------------------------------

class host_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:host_info) */ {
 public:
  host_info();
  virtual ~host_info();

  host_info(const host_info& from);

  inline host_info& operator=(const host_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  host_info(host_info&& from) noexcept
    : host_info() {
    *this = ::std::move(from);
  }

  inline host_info& operator=(host_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const host_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const host_info* internal_default_instance() {
    return reinterpret_cast<const host_info*>(
               &_host_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(host_info* other);
  friend void swap(host_info& a, host_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline host_info* New() const PROTOBUF_FINAL { return New(NULL); }

  host_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const host_info& from);
  void MergeFrom(const host_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(host_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string machine = 1;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 1;
  const ::std::string& machine() const;
  void set_machine(const ::std::string& value);
  #if LANG_CXX11
  void set_machine(::std::string&& value);
  #endif
  void set_machine(const char* value);
  void set_machine(const char* value, size_t size);
  ::std::string* mutable_machine();
  ::std::string* release_machine();
  void set_allocated_machine(::std::string* machine);

  // required string node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::std::string& node() const;
  void set_node(const ::std::string& value);
  #if LANG_CXX11
  void set_node(::std::string&& value);
  #endif
  void set_node(const char* value);
  void set_node(const char* value, size_t size);
  ::std::string* mutable_node();
  ::std::string* release_node();
  void set_allocated_node(::std::string* node);

  // required string platform = 3;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 3;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // required string processor = 4;
  bool has_processor() const;
  void clear_processor();
  static const int kProcessorFieldNumber = 4;
  const ::std::string& processor() const;
  void set_processor(const ::std::string& value);
  #if LANG_CXX11
  void set_processor(::std::string&& value);
  #endif
  void set_processor(const char* value);
  void set_processor(const char* value, size_t size);
  ::std::string* mutable_processor();
  ::std::string* release_processor();
  void set_allocated_processor(::std::string* processor);

  // required string release = 5;
  bool has_release() const;
  void clear_release();
  static const int kReleaseFieldNumber = 5;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  #if LANG_CXX11
  void set_release(::std::string&& value);
  #endif
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // required string system = 6;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 6;
  const ::std::string& system() const;
  void set_system(const ::std::string& value);
  #if LANG_CXX11
  void set_system(::std::string&& value);
  #endif
  void set_system(const char* value);
  void set_system(const char* value, size_t size);
  ::std::string* mutable_system();
  ::std::string* release_system();
  void set_allocated_system(::std::string* system);

  // required string version = 7;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required string sys_platform = 8;
  bool has_sys_platform() const;
  void clear_sys_platform();
  static const int kSysPlatformFieldNumber = 8;
  const ::std::string& sys_platform() const;
  void set_sys_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_sys_platform(::std::string&& value);
  #endif
  void set_sys_platform(const char* value);
  void set_sys_platform(const char* value, size_t size);
  ::std::string* mutable_sys_platform();
  ::std::string* release_sys_platform();
  void set_allocated_sys_platform(::std::string* sys_platform);

  // required string byteorder = 9;
  bool has_byteorder() const;
  void clear_byteorder();
  static const int kByteorderFieldNumber = 9;
  const ::std::string& byteorder() const;
  void set_byteorder(const ::std::string& value);
  #if LANG_CXX11
  void set_byteorder(::std::string&& value);
  #endif
  void set_byteorder(const char* value);
  void set_byteorder(const char* value, size_t size);
  ::std::string* mutable_byteorder();
  ::std::string* release_byteorder();
  void set_allocated_byteorder(::std::string* byteorder);

  // @@protoc_insertion_point(class_scope:host_info)
 private:
  void set_has_machine();
  void clear_has_machine();
  void set_has_node();
  void clear_has_node();
  void set_has_platform();
  void clear_has_platform();
  void set_has_processor();
  void clear_has_processor();
  void set_has_release();
  void clear_has_release();
  void set_has_system();
  void clear_has_system();
  void set_has_version();
  void clear_has_version();
  void set_has_sys_platform();
  void clear_has_sys_platform();
  void set_has_byteorder();
  void clear_has_byteorder();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr machine_;
  ::google::protobuf::internal::ArenaStringPtr node_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr processor_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr system_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr sys_platform_;
  ::google::protobuf::internal::ArenaStringPtr byteorder_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultshost_infoImpl();
};
// -------------------------------------------------------------------

class platform_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:platform_info) */ {
 public:
  platform_info();
  virtual ~platform_info();

  platform_info(const platform_info& from);

  inline platform_info& operator=(const platform_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  platform_info(platform_info&& from) noexcept
    : platform_info() {
    *this = ::std::move(from);
  }

  inline platform_info& operator=(platform_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const platform_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const platform_info* internal_default_instance() {
    return reinterpret_cast<const platform_info*>(
               &_platform_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(platform_info* other);
  friend void swap(platform_info& a, platform_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline platform_info* New() const PROTOBUF_FINAL { return New(NULL); }

  platform_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const platform_info& from);
  void MergeFrom(const platform_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(platform_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // required .python_info python = 2;
  bool has_python() const;
  void clear_python();
  static const int kPythonFieldNumber = 2;
  const ::python_info& python() const;
  ::python_info* release_python();
  ::python_info* mutable_python();
  void set_allocated_python(::python_info* python);

  // required .host_info host = 3;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::host_info& host() const;
  ::host_info* release_host();
  ::host_info* mutable_host();
  void set_allocated_host(::host_info* host);

  // required float start_time = 4;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  float start_time() const;
  void set_start_time(float value);

  // @@protoc_insertion_point(class_scope:platform_info)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_python();
  void clear_has_python();
  void set_has_host();
  void clear_has_host();
  void set_has_start_time();
  void clear_has_start_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::message_header* header_;
  ::python_info* python_;
  ::host_info* host_;
  float start_time_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsplatform_infoImpl();
};
// -------------------------------------------------------------------

class register_for_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:register_for_message) */ {
 public:
  register_for_message();
  virtual ~register_for_message();

  register_for_message(const register_for_message& from);

  inline register_for_message& operator=(const register_for_message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  register_for_message(register_for_message&& from) noexcept
    : register_for_message() {
    *this = ::std::move(from);
  }

  inline register_for_message& operator=(register_for_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const register_for_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const register_for_message* internal_default_instance() {
    return reinterpret_cast<const register_for_message*>(
               &_register_for_message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(register_for_message* other);
  friend void swap(register_for_message& a, register_for_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline register_for_message* New() const PROTOBUF_FINAL { return New(NULL); }

  register_for_message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const register_for_message& from);
  void MergeFrom(const register_for_message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(register_for_message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 2;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // @@protoc_insertion_point(class_scope:register_for_message)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_message_id();
  void clear_has_message_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::message_header* header_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsregister_for_messageImpl();
};
// -------------------------------------------------------------------

class deregister_for_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:deregister_for_message) */ {
 public:
  deregister_for_message();
  virtual ~deregister_for_message();

  deregister_for_message(const deregister_for_message& from);

  inline deregister_for_message& operator=(const deregister_for_message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  deregister_for_message(deregister_for_message&& from) noexcept
    : deregister_for_message() {
    *this = ::std::move(from);
  }

  inline deregister_for_message& operator=(deregister_for_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const deregister_for_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const deregister_for_message* internal_default_instance() {
    return reinterpret_cast<const deregister_for_message*>(
               &_deregister_for_message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(deregister_for_message* other);
  friend void swap(deregister_for_message& a, deregister_for_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline deregister_for_message* New() const PROTOBUF_FINAL { return New(NULL); }

  deregister_for_message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const deregister_for_message& from);
  void MergeFrom(const deregister_for_message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(deregister_for_message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 2;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const ::std::string& message_id() const;
  void set_message_id(const ::std::string& value);
  #if LANG_CXX11
  void set_message_id(::std::string&& value);
  #endif
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  ::std::string* mutable_message_id();
  ::std::string* release_message_id();
  void set_allocated_message_id(::std::string* message_id);

  // required .message_header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::message_header& header() const;
  ::message_header* release_header();
  ::message_header* mutable_header();
  void set_allocated_header(::message_header* header);

  // @@protoc_insertion_point(class_scope:deregister_for_message)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_message_id();
  void clear_has_message_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_id_;
  ::message_header* header_;
  friend struct ::protobuf_aibsmw_5fmessages_2eproto::TableStruct;
  friend void ::protobuf_aibsmw_5fmessages_2eproto::InitDefaultsderegister_for_messageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message_header

// required string process = 1;
inline bool message_header::has_process() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_header::set_has_process() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_header::clear_has_process() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_header::clear_process() {
  process_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_process();
}
inline const ::std::string& message_header::process() const {
  // @@protoc_insertion_point(field_get:message_header.process)
  return process_.GetNoArena();
}
inline void message_header::set_process(const ::std::string& value) {
  set_has_process();
  process_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_header.process)
}
#if LANG_CXX11
inline void message_header::set_process(::std::string&& value) {
  set_has_process();
  process_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_header.process)
}
#endif
inline void message_header::set_process(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_process();
  process_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_header.process)
}
inline void message_header::set_process(const char* value, size_t size) {
  set_has_process();
  process_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_header.process)
}
inline ::std::string* message_header::mutable_process() {
  set_has_process();
  // @@protoc_insertion_point(field_mutable:message_header.process)
  return process_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_header::release_process() {
  // @@protoc_insertion_point(field_release:message_header.process)
  clear_has_process();
  return process_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_header::set_allocated_process(::std::string* process) {
  if (process != NULL) {
    set_has_process();
  } else {
    clear_has_process();
  }
  process_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process);
  // @@protoc_insertion_point(field_set_allocated:message_header.process)
}

// required string host = 2;
inline bool message_header::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_header::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_header::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_header::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& message_header::host() const {
  // @@protoc_insertion_point(field_get:message_header.host)
  return host_.GetNoArena();
}
inline void message_header::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_header.host)
}
#if LANG_CXX11
inline void message_header::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_header.host)
}
#endif
inline void message_header::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_header.host)
}
inline void message_header::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_header.host)
}
inline ::std::string* message_header::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:message_header.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_header::release_host() {
  // @@protoc_insertion_point(field_release:message_header.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_header::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:message_header.host)
}

// required float timestamp = 3;
inline bool message_header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void message_header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void message_header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void message_header::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline float message_header::timestamp() const {
  // @@protoc_insertion_point(field_get:message_header.timestamp)
  return timestamp_;
}
inline void message_header::set_timestamp(float value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:message_header.timestamp)
}

// required string message_id = 4;
inline bool message_header::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_header::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void message_header::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void message_header::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_id();
}
inline const ::std::string& message_header::message_id() const {
  // @@protoc_insertion_point(field_get:message_header.message_id)
  return message_id_.GetNoArena();
}
inline void message_header::set_message_id(const ::std::string& value) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_header.message_id)
}
#if LANG_CXX11
inline void message_header::set_message_id(::std::string&& value) {
  set_has_message_id();
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_header.message_id)
}
#endif
inline void message_header::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_header.message_id)
}
inline void message_header::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_header.message_id)
}
inline ::std::string* message_header::mutable_message_id() {
  set_has_message_id();
  // @@protoc_insertion_point(field_mutable:message_header.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_header::release_message_id() {
  // @@protoc_insertion_point(field_release:message_header.message_id)
  clear_has_message_id();
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_header::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:message_header.message_id)
}

// -------------------------------------------------------------------

// generic_heartbeat

// required .message_header header = 1;
inline bool generic_heartbeat::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void generic_heartbeat::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void generic_heartbeat::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void generic_heartbeat::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& generic_heartbeat::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:generic_heartbeat.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* generic_heartbeat::release_header() {
  // @@protoc_insertion_point(field_release:generic_heartbeat.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* generic_heartbeat::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:generic_heartbeat.header)
  return header_;
}
inline void generic_heartbeat::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:generic_heartbeat.header)
}

// required float start_time = 2;
inline bool generic_heartbeat::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void generic_heartbeat::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void generic_heartbeat::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void generic_heartbeat::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline float generic_heartbeat::start_time() const {
  // @@protoc_insertion_point(field_get:generic_heartbeat.start_time)
  return start_time_;
}
inline void generic_heartbeat::set_start_time(float value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:generic_heartbeat.start_time)
}

// -------------------------------------------------------------------

// remote_device_heartbeat

// required .message_header header = 1;
inline bool remote_device_heartbeat::has_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void remote_device_heartbeat::set_has_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void remote_device_heartbeat::clear_has_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void remote_device_heartbeat::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& remote_device_heartbeat::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:remote_device_heartbeat.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* remote_device_heartbeat::release_header() {
  // @@protoc_insertion_point(field_release:remote_device_heartbeat.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* remote_device_heartbeat::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:remote_device_heartbeat.header)
  return header_;
}
inline void remote_device_heartbeat::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:remote_device_heartbeat.header)
}

// required string device_name = 2;
inline bool remote_device_heartbeat::has_device_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void remote_device_heartbeat::set_has_device_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void remote_device_heartbeat::clear_has_device_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void remote_device_heartbeat::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_name();
}
inline const ::std::string& remote_device_heartbeat::device_name() const {
  // @@protoc_insertion_point(field_get:remote_device_heartbeat.device_name)
  return device_name_.GetNoArena();
}
inline void remote_device_heartbeat::set_device_name(const ::std::string& value) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_device_heartbeat.device_name)
}
#if LANG_CXX11
inline void remote_device_heartbeat::set_device_name(::std::string&& value) {
  set_has_device_name();
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_device_heartbeat.device_name)
}
#endif
inline void remote_device_heartbeat::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_device_heartbeat.device_name)
}
inline void remote_device_heartbeat::set_device_name(const char* value, size_t size) {
  set_has_device_name();
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_device_heartbeat.device_name)
}
inline ::std::string* remote_device_heartbeat::mutable_device_name() {
  set_has_device_name();
  // @@protoc_insertion_point(field_mutable:remote_device_heartbeat.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_device_heartbeat::release_device_name() {
  // @@protoc_insertion_point(field_release:remote_device_heartbeat.device_name)
  clear_has_device_name();
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_device_heartbeat::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    set_has_device_name();
  } else {
    clear_has_device_name();
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:remote_device_heartbeat.device_name)
}

// required string ip_address = 4;
inline bool remote_device_heartbeat::has_ip_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void remote_device_heartbeat::set_has_ip_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void remote_device_heartbeat::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void remote_device_heartbeat::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip_address();
}
inline const ::std::string& remote_device_heartbeat::ip_address() const {
  // @@protoc_insertion_point(field_get:remote_device_heartbeat.ip_address)
  return ip_address_.GetNoArena();
}
inline void remote_device_heartbeat::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_device_heartbeat.ip_address)
}
#if LANG_CXX11
inline void remote_device_heartbeat::set_ip_address(::std::string&& value) {
  set_has_ip_address();
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_device_heartbeat.ip_address)
}
#endif
inline void remote_device_heartbeat::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_device_heartbeat.ip_address)
}
inline void remote_device_heartbeat::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_device_heartbeat.ip_address)
}
inline ::std::string* remote_device_heartbeat::mutable_ip_address() {
  set_has_ip_address();
  // @@protoc_insertion_point(field_mutable:remote_device_heartbeat.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_device_heartbeat::release_ip_address() {
  // @@protoc_insertion_point(field_release:remote_device_heartbeat.ip_address)
  clear_has_ip_address();
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_device_heartbeat::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    set_has_ip_address();
  } else {
    clear_has_ip_address();
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:remote_device_heartbeat.ip_address)
}

// required int32 port = 5;
inline bool remote_device_heartbeat::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void remote_device_heartbeat::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void remote_device_heartbeat::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void remote_device_heartbeat::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 remote_device_heartbeat::port() const {
  // @@protoc_insertion_point(field_get:remote_device_heartbeat.port)
  return port_;
}
inline void remote_device_heartbeat::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:remote_device_heartbeat.port)
}

// required float start_time = 6;
inline bool remote_device_heartbeat::has_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void remote_device_heartbeat::set_has_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void remote_device_heartbeat::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void remote_device_heartbeat::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline float remote_device_heartbeat::start_time() const {
  // @@protoc_insertion_point(field_get:remote_device_heartbeat.start_time)
  return start_time_;
}
inline void remote_device_heartbeat::set_start_time(float value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:remote_device_heartbeat.start_time)
}

// -------------------------------------------------------------------

// request_remote_devices

// required .message_header header = 1;
inline bool request_remote_devices::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void request_remote_devices::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void request_remote_devices::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void request_remote_devices::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& request_remote_devices::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:request_remote_devices.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* request_remote_devices::release_header() {
  // @@protoc_insertion_point(field_release:request_remote_devices.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* request_remote_devices::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:request_remote_devices.header)
  return header_;
}
inline void request_remote_devices::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:request_remote_devices.header)
}

// -------------------------------------------------------------------

// router_alive

// required .message_header header = 1;
inline bool router_alive::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void router_alive::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void router_alive::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void router_alive::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& router_alive::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:router_alive.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* router_alive::release_header() {
  // @@protoc_insertion_point(field_release:router_alive.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* router_alive::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:router_alive.header)
  return header_;
}
inline void router_alive::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:router_alive.header)
}

// repeated string registered_messages = 2;
inline int router_alive::registered_messages_size() const {
  return registered_messages_.size();
}
inline void router_alive::clear_registered_messages() {
  registered_messages_.Clear();
}
inline const ::std::string& router_alive::registered_messages(int index) const {
  // @@protoc_insertion_point(field_get:router_alive.registered_messages)
  return registered_messages_.Get(index);
}
inline ::std::string* router_alive::mutable_registered_messages(int index) {
  // @@protoc_insertion_point(field_mutable:router_alive.registered_messages)
  return registered_messages_.Mutable(index);
}
inline void router_alive::set_registered_messages(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:router_alive.registered_messages)
  registered_messages_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void router_alive::set_registered_messages(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:router_alive.registered_messages)
  registered_messages_.Mutable(index)->assign(std::move(value));
}
#endif
inline void router_alive::set_registered_messages(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  registered_messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:router_alive.registered_messages)
}
inline void router_alive::set_registered_messages(int index, const char* value, size_t size) {
  registered_messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:router_alive.registered_messages)
}
inline ::std::string* router_alive::add_registered_messages() {
  // @@protoc_insertion_point(field_add_mutable:router_alive.registered_messages)
  return registered_messages_.Add();
}
inline void router_alive::add_registered_messages(const ::std::string& value) {
  registered_messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:router_alive.registered_messages)
}
#if LANG_CXX11
inline void router_alive::add_registered_messages(::std::string&& value) {
  registered_messages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:router_alive.registered_messages)
}
#endif
inline void router_alive::add_registered_messages(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  registered_messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:router_alive.registered_messages)
}
inline void router_alive::add_registered_messages(const char* value, size_t size) {
  registered_messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:router_alive.registered_messages)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
router_alive::registered_messages() const {
  // @@protoc_insertion_point(field_list:router_alive.registered_messages)
  return registered_messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
router_alive::mutable_registered_messages() {
  // @@protoc_insertion_point(field_mutable_list:router_alive.registered_messages)
  return &registered_messages_;
}

// -------------------------------------------------------------------

// remote_devices_list

// required .message_header header = 1;
inline bool remote_devices_list::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void remote_devices_list::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void remote_devices_list::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void remote_devices_list::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& remote_devices_list::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:remote_devices_list.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* remote_devices_list::release_header() {
  // @@protoc_insertion_point(field_release:remote_devices_list.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* remote_devices_list::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:remote_devices_list.header)
  return header_;
}
inline void remote_devices_list::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:remote_devices_list.header)
}

// required string devices = 2;
inline bool remote_devices_list::has_devices() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void remote_devices_list::set_has_devices() {
  _has_bits_[0] |= 0x00000001u;
}
inline void remote_devices_list::clear_has_devices() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void remote_devices_list::clear_devices() {
  devices_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devices();
}
inline const ::std::string& remote_devices_list::devices() const {
  // @@protoc_insertion_point(field_get:remote_devices_list.devices)
  return devices_.GetNoArena();
}
inline void remote_devices_list::set_devices(const ::std::string& value) {
  set_has_devices();
  devices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_devices_list.devices)
}
#if LANG_CXX11
inline void remote_devices_list::set_devices(::std::string&& value) {
  set_has_devices();
  devices_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_devices_list.devices)
}
#endif
inline void remote_devices_list::set_devices(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devices();
  devices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_devices_list.devices)
}
inline void remote_devices_list::set_devices(const char* value, size_t size) {
  set_has_devices();
  devices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_devices_list.devices)
}
inline ::std::string* remote_devices_list::mutable_devices() {
  set_has_devices();
  // @@protoc_insertion_point(field_mutable:remote_devices_list.devices)
  return devices_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_devices_list::release_devices() {
  // @@protoc_insertion_point(field_release:remote_devices_list.devices)
  clear_has_devices();
  return devices_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_devices_list::set_allocated_devices(::std::string* devices) {
  if (devices != NULL) {
    set_has_devices();
  } else {
    clear_has_devices();
  }
  devices_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devices);
  // @@protoc_insertion_point(field_set_allocated:remote_devices_list.devices)
}

// -------------------------------------------------------------------

// remote_service_request

// required .message_header header = 1;
inline bool remote_service_request::has_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void remote_service_request::set_has_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void remote_service_request::clear_has_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void remote_service_request::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& remote_service_request::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:remote_service_request.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* remote_service_request::release_header() {
  // @@protoc_insertion_point(field_release:remote_service_request.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* remote_service_request::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:remote_service_request.header)
  return header_;
}
inline void remote_service_request::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:remote_service_request.header)
}

// required .remote_service_request.COMMAND_TYPES command_type = 2;
inline bool remote_service_request::has_command_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void remote_service_request::set_has_command_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void remote_service_request::clear_has_command_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void remote_service_request::clear_command_type() {
  command_type_ = 0;
  clear_has_command_type();
}
inline ::remote_service_request_COMMAND_TYPES remote_service_request::command_type() const {
  // @@protoc_insertion_point(field_get:remote_service_request.command_type)
  return static_cast< ::remote_service_request_COMMAND_TYPES >(command_type_);
}
inline void remote_service_request::set_command_type(::remote_service_request_COMMAND_TYPES value) {
  assert(::remote_service_request_COMMAND_TYPES_IsValid(value));
  set_has_command_type();
  command_type_ = value;
  // @@protoc_insertion_point(field_set:remote_service_request.command_type)
}

// required string target = 3;
inline bool remote_service_request::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void remote_service_request::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void remote_service_request::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void remote_service_request::clear_target() {
  target_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target();
}
inline const ::std::string& remote_service_request::target() const {
  // @@protoc_insertion_point(field_get:remote_service_request.target)
  return target_.GetNoArena();
}
inline void remote_service_request::set_target(const ::std::string& value) {
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_service_request.target)
}
#if LANG_CXX11
inline void remote_service_request::set_target(::std::string&& value) {
  set_has_target();
  target_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_service_request.target)
}
#endif
inline void remote_service_request::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_service_request.target)
}
inline void remote_service_request::set_target(const char* value, size_t size) {
  set_has_target();
  target_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_service_request.target)
}
inline ::std::string* remote_service_request::mutable_target() {
  set_has_target();
  // @@protoc_insertion_point(field_mutable:remote_service_request.target)
  return target_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_service_request::release_target() {
  // @@protoc_insertion_point(field_release:remote_service_request.target)
  clear_has_target();
  return target_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_service_request::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    set_has_target();
  } else {
    clear_has_target();
  }
  target_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:remote_service_request.target)
}

// optional string args = 4;
inline bool remote_service_request::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void remote_service_request::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void remote_service_request::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void remote_service_request::clear_args() {
  args_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_args();
}
inline const ::std::string& remote_service_request::args() const {
  // @@protoc_insertion_point(field_get:remote_service_request.args)
  return args_.GetNoArena();
}
inline void remote_service_request::set_args(const ::std::string& value) {
  set_has_args();
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_service_request.args)
}
#if LANG_CXX11
inline void remote_service_request::set_args(::std::string&& value) {
  set_has_args();
  args_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_service_request.args)
}
#endif
inline void remote_service_request::set_args(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_args();
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_service_request.args)
}
inline void remote_service_request::set_args(const char* value, size_t size) {
  set_has_args();
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_service_request.args)
}
inline ::std::string* remote_service_request::mutable_args() {
  set_has_args();
  // @@protoc_insertion_point(field_mutable:remote_service_request.args)
  return args_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_service_request::release_args() {
  // @@protoc_insertion_point(field_release:remote_service_request.args)
  clear_has_args();
  return args_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_service_request::set_allocated_args(::std::string* args) {
  if (args != NULL) {
    set_has_args();
  } else {
    clear_has_args();
  }
  args_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args);
  // @@protoc_insertion_point(field_set_allocated:remote_service_request.args)
}

// optional string kwargs = 5;
inline bool remote_service_request::has_kwargs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void remote_service_request::set_has_kwargs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void remote_service_request::clear_has_kwargs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void remote_service_request::clear_kwargs() {
  kwargs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_kwargs();
}
inline const ::std::string& remote_service_request::kwargs() const {
  // @@protoc_insertion_point(field_get:remote_service_request.kwargs)
  return kwargs_.GetNoArena();
}
inline void remote_service_request::set_kwargs(const ::std::string& value) {
  set_has_kwargs();
  kwargs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_service_request.kwargs)
}
#if LANG_CXX11
inline void remote_service_request::set_kwargs(::std::string&& value) {
  set_has_kwargs();
  kwargs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_service_request.kwargs)
}
#endif
inline void remote_service_request::set_kwargs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_kwargs();
  kwargs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_service_request.kwargs)
}
inline void remote_service_request::set_kwargs(const char* value, size_t size) {
  set_has_kwargs();
  kwargs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_service_request.kwargs)
}
inline ::std::string* remote_service_request::mutable_kwargs() {
  set_has_kwargs();
  // @@protoc_insertion_point(field_mutable:remote_service_request.kwargs)
  return kwargs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_service_request::release_kwargs() {
  // @@protoc_insertion_point(field_release:remote_service_request.kwargs)
  clear_has_kwargs();
  return kwargs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_service_request::set_allocated_kwargs(::std::string* kwargs) {
  if (kwargs != NULL) {
    set_has_kwargs();
  } else {
    clear_has_kwargs();
  }
  kwargs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kwargs);
  // @@protoc_insertion_point(field_set_allocated:remote_service_request.kwargs)
}

// -------------------------------------------------------------------

// remote_service_reply

// required .message_header header = 1;
inline bool remote_service_reply::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void remote_service_reply::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void remote_service_reply::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void remote_service_reply::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& remote_service_reply::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:remote_service_reply.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* remote_service_reply::release_header() {
  // @@protoc_insertion_point(field_release:remote_service_reply.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* remote_service_reply::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:remote_service_reply.header)
  return header_;
}
inline void remote_service_reply::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:remote_service_reply.header)
}

// required .remote_service_reply.CALL_RESULT_TYPES call_result = 2;
inline bool remote_service_reply::has_call_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void remote_service_reply::set_has_call_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void remote_service_reply::clear_has_call_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void remote_service_reply::clear_call_result() {
  call_result_ = 0;
  clear_has_call_result();
}
inline ::remote_service_reply_CALL_RESULT_TYPES remote_service_reply::call_result() const {
  // @@protoc_insertion_point(field_get:remote_service_reply.call_result)
  return static_cast< ::remote_service_reply_CALL_RESULT_TYPES >(call_result_);
}
inline void remote_service_reply::set_call_result(::remote_service_reply_CALL_RESULT_TYPES value) {
  assert(::remote_service_reply_CALL_RESULT_TYPES_IsValid(value));
  set_has_call_result();
  call_result_ = value;
  // @@protoc_insertion_point(field_set:remote_service_reply.call_result)
}

// required string reply = 3;
inline bool remote_service_reply::has_reply() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void remote_service_reply::set_has_reply() {
  _has_bits_[0] |= 0x00000001u;
}
inline void remote_service_reply::clear_has_reply() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void remote_service_reply::clear_reply() {
  reply_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reply();
}
inline const ::std::string& remote_service_reply::reply() const {
  // @@protoc_insertion_point(field_get:remote_service_reply.reply)
  return reply_.GetNoArena();
}
inline void remote_service_reply::set_reply(const ::std::string& value) {
  set_has_reply();
  reply_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:remote_service_reply.reply)
}
#if LANG_CXX11
inline void remote_service_reply::set_reply(::std::string&& value) {
  set_has_reply();
  reply_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:remote_service_reply.reply)
}
#endif
inline void remote_service_reply::set_reply(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reply();
  reply_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:remote_service_reply.reply)
}
inline void remote_service_reply::set_reply(const char* value, size_t size) {
  set_has_reply();
  reply_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:remote_service_reply.reply)
}
inline ::std::string* remote_service_reply::mutable_reply() {
  set_has_reply();
  // @@protoc_insertion_point(field_mutable:remote_service_reply.reply)
  return reply_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* remote_service_reply::release_reply() {
  // @@protoc_insertion_point(field_release:remote_service_reply.reply)
  clear_has_reply();
  return reply_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void remote_service_reply::set_allocated_reply(::std::string* reply) {
  if (reply != NULL) {
    set_has_reply();
  } else {
    clear_has_reply();
  }
  reply_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reply);
  // @@protoc_insertion_point(field_set_allocated:remote_service_reply.reply)
}

// -------------------------------------------------------------------

// system_notification

// required .message_header header = 1;
inline bool system_notification::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void system_notification::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void system_notification::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void system_notification::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& system_notification::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:system_notification.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* system_notification::release_header() {
  // @@protoc_insertion_point(field_release:system_notification.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* system_notification::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:system_notification.header)
  return header_;
}
inline void system_notification::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:system_notification.header)
}

// required .system_notification.status_type status = 2;
inline bool system_notification::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void system_notification::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void system_notification::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void system_notification::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::system_notification_status_type system_notification::status() const {
  // @@protoc_insertion_point(field_get:system_notification.status)
  return static_cast< ::system_notification_status_type >(status_);
}
inline void system_notification::set_status(::system_notification_status_type value) {
  assert(::system_notification_status_type_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:system_notification.status)
}

// required string message = 3;
inline bool system_notification::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void system_notification::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void system_notification::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void system_notification::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& system_notification::message() const {
  // @@protoc_insertion_point(field_get:system_notification.message)
  return message_.GetNoArena();
}
inline void system_notification::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:system_notification.message)
}
#if LANG_CXX11
inline void system_notification::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:system_notification.message)
}
#endif
inline void system_notification::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:system_notification.message)
}
inline void system_notification::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:system_notification.message)
}
inline ::std::string* system_notification::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:system_notification.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* system_notification::release_message() {
  // @@protoc_insertion_point(field_release:system_notification.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void system_notification::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:system_notification.message)
}

// -------------------------------------------------------------------

// python_info

// required string build_number = 1;
inline bool python_info::has_build_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void python_info::set_has_build_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void python_info::clear_has_build_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void python_info::clear_build_number() {
  build_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_number();
}
inline const ::std::string& python_info::build_number() const {
  // @@protoc_insertion_point(field_get:python_info.build_number)
  return build_number_.GetNoArena();
}
inline void python_info::set_build_number(const ::std::string& value) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.build_number)
}
#if LANG_CXX11
inline void python_info::set_build_number(::std::string&& value) {
  set_has_build_number();
  build_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.build_number)
}
#endif
inline void python_info::set_build_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.build_number)
}
inline void python_info::set_build_number(const char* value, size_t size) {
  set_has_build_number();
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.build_number)
}
inline ::std::string* python_info::mutable_build_number() {
  set_has_build_number();
  // @@protoc_insertion_point(field_mutable:python_info.build_number)
  return build_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_build_number() {
  // @@protoc_insertion_point(field_release:python_info.build_number)
  clear_has_build_number();
  return build_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_build_number(::std::string* build_number) {
  if (build_number != NULL) {
    set_has_build_number();
  } else {
    clear_has_build_number();
  }
  build_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_number);
  // @@protoc_insertion_point(field_set_allocated:python_info.build_number)
}

// required string build_date = 2;
inline bool python_info::has_build_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void python_info::set_has_build_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void python_info::clear_has_build_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void python_info::clear_build_date() {
  build_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_date();
}
inline const ::std::string& python_info::build_date() const {
  // @@protoc_insertion_point(field_get:python_info.build_date)
  return build_date_.GetNoArena();
}
inline void python_info::set_build_date(const ::std::string& value) {
  set_has_build_date();
  build_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.build_date)
}
#if LANG_CXX11
inline void python_info::set_build_date(::std::string&& value) {
  set_has_build_date();
  build_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.build_date)
}
#endif
inline void python_info::set_build_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_build_date();
  build_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.build_date)
}
inline void python_info::set_build_date(const char* value, size_t size) {
  set_has_build_date();
  build_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.build_date)
}
inline ::std::string* python_info::mutable_build_date() {
  set_has_build_date();
  // @@protoc_insertion_point(field_mutable:python_info.build_date)
  return build_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_build_date() {
  // @@protoc_insertion_point(field_release:python_info.build_date)
  clear_has_build_date();
  return build_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_build_date(::std::string* build_date) {
  if (build_date != NULL) {
    set_has_build_date();
  } else {
    clear_has_build_date();
  }
  build_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_date);
  // @@protoc_insertion_point(field_set_allocated:python_info.build_date)
}

// required string compiler = 3;
inline bool python_info::has_compiler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void python_info::set_has_compiler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void python_info::clear_has_compiler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void python_info::clear_compiler() {
  compiler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_compiler();
}
inline const ::std::string& python_info::compiler() const {
  // @@protoc_insertion_point(field_get:python_info.compiler)
  return compiler_.GetNoArena();
}
inline void python_info::set_compiler(const ::std::string& value) {
  set_has_compiler();
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.compiler)
}
#if LANG_CXX11
inline void python_info::set_compiler(::std::string&& value) {
  set_has_compiler();
  compiler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.compiler)
}
#endif
inline void python_info::set_compiler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_compiler();
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.compiler)
}
inline void python_info::set_compiler(const char* value, size_t size) {
  set_has_compiler();
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.compiler)
}
inline ::std::string* python_info::mutable_compiler() {
  set_has_compiler();
  // @@protoc_insertion_point(field_mutable:python_info.compiler)
  return compiler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_compiler() {
  // @@protoc_insertion_point(field_release:python_info.compiler)
  clear_has_compiler();
  return compiler_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_compiler(::std::string* compiler) {
  if (compiler != NULL) {
    set_has_compiler();
  } else {
    clear_has_compiler();
  }
  compiler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compiler);
  // @@protoc_insertion_point(field_set_allocated:python_info.compiler)
}

// required string branch = 4;
inline bool python_info::has_branch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void python_info::set_has_branch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void python_info::clear_has_branch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void python_info::clear_branch() {
  branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_branch();
}
inline const ::std::string& python_info::branch() const {
  // @@protoc_insertion_point(field_get:python_info.branch)
  return branch_.GetNoArena();
}
inline void python_info::set_branch(const ::std::string& value) {
  set_has_branch();
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.branch)
}
#if LANG_CXX11
inline void python_info::set_branch(::std::string&& value) {
  set_has_branch();
  branch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.branch)
}
#endif
inline void python_info::set_branch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_branch();
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.branch)
}
inline void python_info::set_branch(const char* value, size_t size) {
  set_has_branch();
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.branch)
}
inline ::std::string* python_info::mutable_branch() {
  set_has_branch();
  // @@protoc_insertion_point(field_mutable:python_info.branch)
  return branch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_branch() {
  // @@protoc_insertion_point(field_release:python_info.branch)
  clear_has_branch();
  return branch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_branch(::std::string* branch) {
  if (branch != NULL) {
    set_has_branch();
  } else {
    clear_has_branch();
  }
  branch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), branch);
  // @@protoc_insertion_point(field_set_allocated:python_info.branch)
}

// required string implementation = 5;
inline bool python_info::has_implementation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void python_info::set_has_implementation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void python_info::clear_has_implementation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void python_info::clear_implementation() {
  implementation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_implementation();
}
inline const ::std::string& python_info::implementation() const {
  // @@protoc_insertion_point(field_get:python_info.implementation)
  return implementation_.GetNoArena();
}
inline void python_info::set_implementation(const ::std::string& value) {
  set_has_implementation();
  implementation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.implementation)
}
#if LANG_CXX11
inline void python_info::set_implementation(::std::string&& value) {
  set_has_implementation();
  implementation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.implementation)
}
#endif
inline void python_info::set_implementation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_implementation();
  implementation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.implementation)
}
inline void python_info::set_implementation(const char* value, size_t size) {
  set_has_implementation();
  implementation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.implementation)
}
inline ::std::string* python_info::mutable_implementation() {
  set_has_implementation();
  // @@protoc_insertion_point(field_mutable:python_info.implementation)
  return implementation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_implementation() {
  // @@protoc_insertion_point(field_release:python_info.implementation)
  clear_has_implementation();
  return implementation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_implementation(::std::string* implementation) {
  if (implementation != NULL) {
    set_has_implementation();
  } else {
    clear_has_implementation();
  }
  implementation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), implementation);
  // @@protoc_insertion_point(field_set_allocated:python_info.implementation)
}

// required string revision = 6;
inline bool python_info::has_revision() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void python_info::set_has_revision() {
  _has_bits_[0] |= 0x00000020u;
}
inline void python_info::clear_has_revision() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void python_info::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_revision();
}
inline const ::std::string& python_info::revision() const {
  // @@protoc_insertion_point(field_get:python_info.revision)
  return revision_.GetNoArena();
}
inline void python_info::set_revision(const ::std::string& value) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.revision)
}
#if LANG_CXX11
inline void python_info::set_revision(::std::string&& value) {
  set_has_revision();
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.revision)
}
#endif
inline void python_info::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.revision)
}
inline void python_info::set_revision(const char* value, size_t size) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.revision)
}
inline ::std::string* python_info::mutable_revision() {
  set_has_revision();
  // @@protoc_insertion_point(field_mutable:python_info.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_revision() {
  // @@protoc_insertion_point(field_release:python_info.revision)
  clear_has_revision();
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    set_has_revision();
  } else {
    clear_has_revision();
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:python_info.revision)
}

// required string version = 7;
inline bool python_info::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void python_info::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void python_info::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void python_info::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& python_info::version() const {
  // @@protoc_insertion_point(field_get:python_info.version)
  return version_.GetNoArena();
}
inline void python_info::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.version)
}
#if LANG_CXX11
inline void python_info::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.version)
}
#endif
inline void python_info::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.version)
}
inline void python_info::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.version)
}
inline ::std::string* python_info::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:python_info.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_version() {
  // @@protoc_insertion_point(field_release:python_info.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:python_info.version)
}

// required string exec_prefix = 8;
inline bool python_info::has_exec_prefix() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void python_info::set_has_exec_prefix() {
  _has_bits_[0] |= 0x00000080u;
}
inline void python_info::clear_has_exec_prefix() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void python_info::clear_exec_prefix() {
  exec_prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exec_prefix();
}
inline const ::std::string& python_info::exec_prefix() const {
  // @@protoc_insertion_point(field_get:python_info.exec_prefix)
  return exec_prefix_.GetNoArena();
}
inline void python_info::set_exec_prefix(const ::std::string& value) {
  set_has_exec_prefix();
  exec_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:python_info.exec_prefix)
}
#if LANG_CXX11
inline void python_info::set_exec_prefix(::std::string&& value) {
  set_has_exec_prefix();
  exec_prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:python_info.exec_prefix)
}
#endif
inline void python_info::set_exec_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exec_prefix();
  exec_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:python_info.exec_prefix)
}
inline void python_info::set_exec_prefix(const char* value, size_t size) {
  set_has_exec_prefix();
  exec_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:python_info.exec_prefix)
}
inline ::std::string* python_info::mutable_exec_prefix() {
  set_has_exec_prefix();
  // @@protoc_insertion_point(field_mutable:python_info.exec_prefix)
  return exec_prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* python_info::release_exec_prefix() {
  // @@protoc_insertion_point(field_release:python_info.exec_prefix)
  clear_has_exec_prefix();
  return exec_prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void python_info::set_allocated_exec_prefix(::std::string* exec_prefix) {
  if (exec_prefix != NULL) {
    set_has_exec_prefix();
  } else {
    clear_has_exec_prefix();
  }
  exec_prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exec_prefix);
  // @@protoc_insertion_point(field_set_allocated:python_info.exec_prefix)
}

// required bool is_conda = 10;
inline bool python_info::has_is_conda() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void python_info::set_has_is_conda() {
  _has_bits_[0] |= 0x00000100u;
}
inline void python_info::clear_has_is_conda() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void python_info::clear_is_conda() {
  is_conda_ = false;
  clear_has_is_conda();
}
inline bool python_info::is_conda() const {
  // @@protoc_insertion_point(field_get:python_info.is_conda)
  return is_conda_;
}
inline void python_info::set_is_conda(bool value) {
  set_has_is_conda();
  is_conda_ = value;
  // @@protoc_insertion_point(field_set:python_info.is_conda)
}

// -------------------------------------------------------------------

// host_info

// required string machine = 1;
inline bool host_info::has_machine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void host_info::set_has_machine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void host_info::clear_has_machine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void host_info::clear_machine() {
  machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine();
}
inline const ::std::string& host_info::machine() const {
  // @@protoc_insertion_point(field_get:host_info.machine)
  return machine_.GetNoArena();
}
inline void host_info::set_machine(const ::std::string& value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.machine)
}
#if LANG_CXX11
inline void host_info::set_machine(::std::string&& value) {
  set_has_machine();
  machine_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.machine)
}
#endif
inline void host_info::set_machine(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.machine)
}
inline void host_info::set_machine(const char* value, size_t size) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.machine)
}
inline ::std::string* host_info::mutable_machine() {
  set_has_machine();
  // @@protoc_insertion_point(field_mutable:host_info.machine)
  return machine_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_machine() {
  // @@protoc_insertion_point(field_release:host_info.machine)
  clear_has_machine();
  return machine_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_machine(::std::string* machine) {
  if (machine != NULL) {
    set_has_machine();
  } else {
    clear_has_machine();
  }
  machine_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine);
  // @@protoc_insertion_point(field_set_allocated:host_info.machine)
}

// required string node = 2;
inline bool host_info::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void host_info::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void host_info::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void host_info::clear_node() {
  node_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node();
}
inline const ::std::string& host_info::node() const {
  // @@protoc_insertion_point(field_get:host_info.node)
  return node_.GetNoArena();
}
inline void host_info::set_node(const ::std::string& value) {
  set_has_node();
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.node)
}
#if LANG_CXX11
inline void host_info::set_node(::std::string&& value) {
  set_has_node();
  node_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.node)
}
#endif
inline void host_info::set_node(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node();
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.node)
}
inline void host_info::set_node(const char* value, size_t size) {
  set_has_node();
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.node)
}
inline ::std::string* host_info::mutable_node() {
  set_has_node();
  // @@protoc_insertion_point(field_mutable:host_info.node)
  return node_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_node() {
  // @@protoc_insertion_point(field_release:host_info.node)
  clear_has_node();
  return node_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_node(::std::string* node) {
  if (node != NULL) {
    set_has_node();
  } else {
    clear_has_node();
  }
  node_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node);
  // @@protoc_insertion_point(field_set_allocated:host_info.node)
}

// required string platform = 3;
inline bool host_info::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void host_info::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void host_info::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void host_info::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
inline const ::std::string& host_info::platform() const {
  // @@protoc_insertion_point(field_get:host_info.platform)
  return platform_.GetNoArena();
}
inline void host_info::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.platform)
}
#if LANG_CXX11
inline void host_info::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.platform)
}
#endif
inline void host_info::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.platform)
}
inline void host_info::set_platform(const char* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.platform)
}
inline ::std::string* host_info::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:host_info.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_platform() {
  // @@protoc_insertion_point(field_release:host_info.platform)
  clear_has_platform();
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:host_info.platform)
}

// required string processor = 4;
inline bool host_info::has_processor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void host_info::set_has_processor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void host_info::clear_has_processor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void host_info::clear_processor() {
  processor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_processor();
}
inline const ::std::string& host_info::processor() const {
  // @@protoc_insertion_point(field_get:host_info.processor)
  return processor_.GetNoArena();
}
inline void host_info::set_processor(const ::std::string& value) {
  set_has_processor();
  processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.processor)
}
#if LANG_CXX11
inline void host_info::set_processor(::std::string&& value) {
  set_has_processor();
  processor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.processor)
}
#endif
inline void host_info::set_processor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_processor();
  processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.processor)
}
inline void host_info::set_processor(const char* value, size_t size) {
  set_has_processor();
  processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.processor)
}
inline ::std::string* host_info::mutable_processor() {
  set_has_processor();
  // @@protoc_insertion_point(field_mutable:host_info.processor)
  return processor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_processor() {
  // @@protoc_insertion_point(field_release:host_info.processor)
  clear_has_processor();
  return processor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_processor(::std::string* processor) {
  if (processor != NULL) {
    set_has_processor();
  } else {
    clear_has_processor();
  }
  processor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor);
  // @@protoc_insertion_point(field_set_allocated:host_info.processor)
}

// required string release = 5;
inline bool host_info::has_release() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void host_info::set_has_release() {
  _has_bits_[0] |= 0x00000010u;
}
inline void host_info::clear_has_release() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void host_info::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
inline const ::std::string& host_info::release() const {
  // @@protoc_insertion_point(field_get:host_info.release)
  return release_.GetNoArena();
}
inline void host_info::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.release)
}
#if LANG_CXX11
inline void host_info::set_release(::std::string&& value) {
  set_has_release();
  release_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.release)
}
#endif
inline void host_info::set_release(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.release)
}
inline void host_info::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.release)
}
inline ::std::string* host_info::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:host_info.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_release() {
  // @@protoc_insertion_point(field_release:host_info.release)
  clear_has_release();
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:host_info.release)
}

// required string system = 6;
inline bool host_info::has_system() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void host_info::set_has_system() {
  _has_bits_[0] |= 0x00000020u;
}
inline void host_info::clear_has_system() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void host_info::clear_system() {
  system_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system();
}
inline const ::std::string& host_info::system() const {
  // @@protoc_insertion_point(field_get:host_info.system)
  return system_.GetNoArena();
}
inline void host_info::set_system(const ::std::string& value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.system)
}
#if LANG_CXX11
inline void host_info::set_system(::std::string&& value) {
  set_has_system();
  system_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.system)
}
#endif
inline void host_info::set_system(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.system)
}
inline void host_info::set_system(const char* value, size_t size) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.system)
}
inline ::std::string* host_info::mutable_system() {
  set_has_system();
  // @@protoc_insertion_point(field_mutable:host_info.system)
  return system_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_system() {
  // @@protoc_insertion_point(field_release:host_info.system)
  clear_has_system();
  return system_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_system(::std::string* system) {
  if (system != NULL) {
    set_has_system();
  } else {
    clear_has_system();
  }
  system_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system);
  // @@protoc_insertion_point(field_set_allocated:host_info.system)
}

// required string version = 7;
inline bool host_info::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void host_info::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void host_info::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void host_info::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& host_info::version() const {
  // @@protoc_insertion_point(field_get:host_info.version)
  return version_.GetNoArena();
}
inline void host_info::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.version)
}
#if LANG_CXX11
inline void host_info::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.version)
}
#endif
inline void host_info::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.version)
}
inline void host_info::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.version)
}
inline ::std::string* host_info::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:host_info.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_version() {
  // @@protoc_insertion_point(field_release:host_info.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:host_info.version)
}

// required string sys_platform = 8;
inline bool host_info::has_sys_platform() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void host_info::set_has_sys_platform() {
  _has_bits_[0] |= 0x00000080u;
}
inline void host_info::clear_has_sys_platform() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void host_info::clear_sys_platform() {
  sys_platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sys_platform();
}
inline const ::std::string& host_info::sys_platform() const {
  // @@protoc_insertion_point(field_get:host_info.sys_platform)
  return sys_platform_.GetNoArena();
}
inline void host_info::set_sys_platform(const ::std::string& value) {
  set_has_sys_platform();
  sys_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.sys_platform)
}
#if LANG_CXX11
inline void host_info::set_sys_platform(::std::string&& value) {
  set_has_sys_platform();
  sys_platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.sys_platform)
}
#endif
inline void host_info::set_sys_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sys_platform();
  sys_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.sys_platform)
}
inline void host_info::set_sys_platform(const char* value, size_t size) {
  set_has_sys_platform();
  sys_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.sys_platform)
}
inline ::std::string* host_info::mutable_sys_platform() {
  set_has_sys_platform();
  // @@protoc_insertion_point(field_mutable:host_info.sys_platform)
  return sys_platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_sys_platform() {
  // @@protoc_insertion_point(field_release:host_info.sys_platform)
  clear_has_sys_platform();
  return sys_platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_sys_platform(::std::string* sys_platform) {
  if (sys_platform != NULL) {
    set_has_sys_platform();
  } else {
    clear_has_sys_platform();
  }
  sys_platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sys_platform);
  // @@protoc_insertion_point(field_set_allocated:host_info.sys_platform)
}

// required string byteorder = 9;
inline bool host_info::has_byteorder() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void host_info::set_has_byteorder() {
  _has_bits_[0] |= 0x00000100u;
}
inline void host_info::clear_has_byteorder() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void host_info::clear_byteorder() {
  byteorder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_byteorder();
}
inline const ::std::string& host_info::byteorder() const {
  // @@protoc_insertion_point(field_get:host_info.byteorder)
  return byteorder_.GetNoArena();
}
inline void host_info::set_byteorder(const ::std::string& value) {
  set_has_byteorder();
  byteorder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:host_info.byteorder)
}
#if LANG_CXX11
inline void host_info::set_byteorder(::std::string&& value) {
  set_has_byteorder();
  byteorder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:host_info.byteorder)
}
#endif
inline void host_info::set_byteorder(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_byteorder();
  byteorder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:host_info.byteorder)
}
inline void host_info::set_byteorder(const char* value, size_t size) {
  set_has_byteorder();
  byteorder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:host_info.byteorder)
}
inline ::std::string* host_info::mutable_byteorder() {
  set_has_byteorder();
  // @@protoc_insertion_point(field_mutable:host_info.byteorder)
  return byteorder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* host_info::release_byteorder() {
  // @@protoc_insertion_point(field_release:host_info.byteorder)
  clear_has_byteorder();
  return byteorder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void host_info::set_allocated_byteorder(::std::string* byteorder) {
  if (byteorder != NULL) {
    set_has_byteorder();
  } else {
    clear_has_byteorder();
  }
  byteorder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), byteorder);
  // @@protoc_insertion_point(field_set_allocated:host_info.byteorder)
}

// -------------------------------------------------------------------

// platform_info

// required .message_header header = 1;
inline bool platform_info::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void platform_info::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void platform_info::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void platform_info::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& platform_info::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:platform_info.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* platform_info::release_header() {
  // @@protoc_insertion_point(field_release:platform_info.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* platform_info::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:platform_info.header)
  return header_;
}
inline void platform_info::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:platform_info.header)
}

// required .python_info python = 2;
inline bool platform_info::has_python() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void platform_info::set_has_python() {
  _has_bits_[0] |= 0x00000002u;
}
inline void platform_info::clear_has_python() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void platform_info::clear_python() {
  if (python_ != NULL) python_->Clear();
  clear_has_python();
}
inline const ::python_info& platform_info::python() const {
  const ::python_info* p = python_;
  // @@protoc_insertion_point(field_get:platform_info.python)
  return p != NULL ? *p : *reinterpret_cast<const ::python_info*>(
      &::_python_info_default_instance_);
}
inline ::python_info* platform_info::release_python() {
  // @@protoc_insertion_point(field_release:platform_info.python)
  clear_has_python();
  ::python_info* temp = python_;
  python_ = NULL;
  return temp;
}
inline ::python_info* platform_info::mutable_python() {
  set_has_python();
  if (python_ == NULL) {
    python_ = new ::python_info;
  }
  // @@protoc_insertion_point(field_mutable:platform_info.python)
  return python_;
}
inline void platform_info::set_allocated_python(::python_info* python) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete python_;
  }
  if (python) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      python = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, python, submessage_arena);
    }
    set_has_python();
  } else {
    clear_has_python();
  }
  python_ = python;
  // @@protoc_insertion_point(field_set_allocated:platform_info.python)
}

// required .host_info host = 3;
inline bool platform_info::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void platform_info::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void platform_info::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void platform_info::clear_host() {
  if (host_ != NULL) host_->Clear();
  clear_has_host();
}
inline const ::host_info& platform_info::host() const {
  const ::host_info* p = host_;
  // @@protoc_insertion_point(field_get:platform_info.host)
  return p != NULL ? *p : *reinterpret_cast<const ::host_info*>(
      &::_host_info_default_instance_);
}
inline ::host_info* platform_info::release_host() {
  // @@protoc_insertion_point(field_release:platform_info.host)
  clear_has_host();
  ::host_info* temp = host_;
  host_ = NULL;
  return temp;
}
inline ::host_info* platform_info::mutable_host() {
  set_has_host();
  if (host_ == NULL) {
    host_ = new ::host_info;
  }
  // @@protoc_insertion_point(field_mutable:platform_info.host)
  return host_;
}
inline void platform_info::set_allocated_host(::host_info* host) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete host_;
  }
  if (host) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      host = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host, submessage_arena);
    }
    set_has_host();
  } else {
    clear_has_host();
  }
  host_ = host;
  // @@protoc_insertion_point(field_set_allocated:platform_info.host)
}

// required float start_time = 4;
inline bool platform_info::has_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void platform_info::set_has_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void platform_info::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void platform_info::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline float platform_info::start_time() const {
  // @@protoc_insertion_point(field_get:platform_info.start_time)
  return start_time_;
}
inline void platform_info::set_start_time(float value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:platform_info.start_time)
}

// -------------------------------------------------------------------

// register_for_message

// required .message_header header = 1;
inline bool register_for_message::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void register_for_message::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void register_for_message::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void register_for_message::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& register_for_message::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:register_for_message.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* register_for_message::release_header() {
  // @@protoc_insertion_point(field_release:register_for_message.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* register_for_message::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:register_for_message.header)
  return header_;
}
inline void register_for_message::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:register_for_message.header)
}

// required string message_id = 2;
inline bool register_for_message::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void register_for_message::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void register_for_message::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void register_for_message::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_id();
}
inline const ::std::string& register_for_message::message_id() const {
  // @@protoc_insertion_point(field_get:register_for_message.message_id)
  return message_id_.GetNoArena();
}
inline void register_for_message::set_message_id(const ::std::string& value) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:register_for_message.message_id)
}
#if LANG_CXX11
inline void register_for_message::set_message_id(::std::string&& value) {
  set_has_message_id();
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:register_for_message.message_id)
}
#endif
inline void register_for_message::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:register_for_message.message_id)
}
inline void register_for_message::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:register_for_message.message_id)
}
inline ::std::string* register_for_message::mutable_message_id() {
  set_has_message_id();
  // @@protoc_insertion_point(field_mutable:register_for_message.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* register_for_message::release_message_id() {
  // @@protoc_insertion_point(field_release:register_for_message.message_id)
  clear_has_message_id();
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void register_for_message::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:register_for_message.message_id)
}

// -------------------------------------------------------------------

// deregister_for_message

// required .message_header header = 1;
inline bool deregister_for_message::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void deregister_for_message::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void deregister_for_message::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void deregister_for_message::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::message_header& deregister_for_message::header() const {
  const ::message_header* p = header_;
  // @@protoc_insertion_point(field_get:deregister_for_message.header)
  return p != NULL ? *p : *reinterpret_cast<const ::message_header*>(
      &::_message_header_default_instance_);
}
inline ::message_header* deregister_for_message::release_header() {
  // @@protoc_insertion_point(field_release:deregister_for_message.header)
  clear_has_header();
  ::message_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::message_header* deregister_for_message::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::message_header;
  }
  // @@protoc_insertion_point(field_mutable:deregister_for_message.header)
  return header_;
}
inline void deregister_for_message::set_allocated_header(::message_header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:deregister_for_message.header)
}

// required string message_id = 2;
inline bool deregister_for_message::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void deregister_for_message::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void deregister_for_message::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void deregister_for_message::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_id();
}
inline const ::std::string& deregister_for_message::message_id() const {
  // @@protoc_insertion_point(field_get:deregister_for_message.message_id)
  return message_id_.GetNoArena();
}
inline void deregister_for_message::set_message_id(const ::std::string& value) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:deregister_for_message.message_id)
}
#if LANG_CXX11
inline void deregister_for_message::set_message_id(::std::string&& value) {
  set_has_message_id();
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:deregister_for_message.message_id)
}
#endif
inline void deregister_for_message::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:deregister_for_message.message_id)
}
inline void deregister_for_message::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:deregister_for_message.message_id)
}
inline ::std::string* deregister_for_message::mutable_message_id() {
  set_has_message_id();
  // @@protoc_insertion_point(field_mutable:deregister_for_message.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* deregister_for_message::release_message_id() {
  // @@protoc_insertion_point(field_release:deregister_for_message.message_id)
  clear_has_message_id();
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void deregister_for_message::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:deregister_for_message.message_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::remote_service_request_COMMAND_TYPES> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote_service_request_COMMAND_TYPES>() {
  return ::remote_service_request_COMMAND_TYPES_descriptor();
}
template <> struct is_proto_enum< ::remote_service_reply_CALL_RESULT_TYPES> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::remote_service_reply_CALL_RESULT_TYPES>() {
  return ::remote_service_reply_CALL_RESULT_TYPES_descriptor();
}
template <> struct is_proto_enum< ::system_notification_status_type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::system_notification_status_type>() {
  return ::system_notification_status_type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_aibsmw_5fmessages_2eproto__INCLUDED
